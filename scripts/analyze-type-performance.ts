#!/usr/bin/env bun

/**
 * TypeScript Type Performance Analyzer
 *
 * This script helps identify TypeScript performance issues by analyzing
 * type instantiation traces generated by the TypeScript compiler.
 *
 * Usage:
 *   1. Run: bun run scripts/analyze-type-performance.ts
 *   2. The script will generate traces and show the most expensive types
 *
 * You can also manually generate traces with:
 *   tsc --generateTrace trace --noEmit
 *
 * Then analyze with:
 *   bun run scripts/analyze-type-performance.ts --analyze trace
 */

import { execSync } from 'child_process';
import { existsSync, readFileSync, mkdirSync, rmSync, writeFileSync } from 'fs';
import { join } from 'path';

interface TypeInstantiation {
  id: number;
  path: string;
  kind: string;
  count: number;
}

interface TraceEvent {
  name?: string;
  cat?: string;
  dur?: number;
  args?: {
    path?: string;
    count?: number;
  };
}

function generateTrace(targetPath: string = '.') {
  const tracePath = join(process.cwd(), 'trace');

  // Clean up old trace
  if (existsSync(tracePath)) {
    rmSync(tracePath, { recursive: true, force: true });
  }

  mkdirSync(tracePath, { recursive: true });

  console.log('üîç Generating TypeScript trace data...');
  console.log('   This may take a while for large projects...\n');

  try {
    execSync(`tsc --generateTrace trace --noEmit --skipLibCheck`, {
      cwd: process.cwd(),
      stdio: 'pipe',
    });

    return tracePath;
  } catch (error: any) {
    // Trace generation often "fails" but still produces useful output
    if (existsSync(join(tracePath, 'trace.json'))) {
      console.log('‚ö†Ô∏è  Warning: tsc exited with errors, but trace was generated\n');
      return tracePath;
    }

    console.error('\n‚ùå Failed to generate trace.');
    console.error('   Try running manually: tsc --generateTrace trace --noEmit --skipLibCheck\n');
    console.error('   If you have project references, this feature may not work properly.');
    console.error('   Consider testing specific packages instead.\n');
    process.exit(1);
  }
}

function analyzeTrace(tracePath: string) {
  const traceFile = join(tracePath, 'trace.json');

  if (!existsSync(traceFile)) {
    console.error(`Trace file not found at ${traceFile}`);
    process.exit(1);
  }

  console.log('üìä Analyzing trace data...\n');

  // TypeScript trace files are in Chrome trace format (JSON array)
  // but may be incomplete if tsc crashed, so we need to handle that
  let traceContent = readFileSync(traceFile, 'utf-8').trim();

  // Handle incomplete JSON array
  if (!traceContent.endsWith(']')) {
    // Remove trailing comma if present
    traceContent = traceContent.replace(/,\s*$/, '');
    traceContent += ']';
  }

  let trace: TraceEvent[];
  try {
    trace = JSON.parse(traceContent);
  } catch (error) {
    console.error('‚ùå Failed to parse trace file. The trace may be corrupted.');
    console.error('   Try running: tsc --generateTrace trace --noEmit manually');
    process.exit(1);
  }

  // Collect type checking events
  const typeChecks = trace.filter(
    (event) => event.name && event.name.includes('check') && event.dur,
  );

  // Sort by duration (slowest first)
  const slowestChecks = typeChecks.sort((a, b) => (b.dur || 0) - (a.dur || 0)).slice(0, 20);

  console.log('‚è±Ô∏è  Top 20 Slowest Type Checks:\n');
  console.log('Duration (ms) | Event');
  console.log('--------------|------');

  for (const check of slowestChecks) {
    const durationMs = ((check.dur || 0) / 1000).toFixed(2);
    const name = check.name || 'unknown';
    console.log(`${durationMs.padStart(13)} | ${name}`);
  }

  // Collect instantiation counts
  const instantiations = new Map<string, number>();

  for (const event of trace) {
    if (event.args?.path && event.args?.count) {
      const existing = instantiations.get(event.args.path) || 0;
      instantiations.set(event.args.path, existing + event.args.count);
    }
  }

  if (instantiations.size > 0) {
    const sorted = Array.from(instantiations.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 20);

    console.log('\n\nüìà Top 20 Files by Type Instantiations:\n');
    console.log('Count     | File');
    console.log('----------|-----');

    for (const [path, count] of sorted) {
      const shortPath = path.replace(process.cwd(), '.');
      console.log(`${count.toString().padStart(9)} | ${shortPath}`);
    }
  }

  // Calculate total time
  const totalDuration = trace.reduce((sum, event) => sum + (event.dur || 0), 0);
  const totalMs = (totalDuration / 1000).toFixed(2);

  console.log(`\n\n‚è±Ô∏è  Total Type Checking Time: ${totalMs}ms`);
  console.log(`üìù Total Events: ${trace.length}`);

  console.log('\nüí° Tips for Improving Performance:');
  console.log('   - Focus on files with high instantiation counts');
  console.log('   - Simplify complex union and intersection types');
  console.log('   - Extract inline types into named type aliases');
  console.log('   - Use explicit type annotations to reduce inference');
  console.log('   - Avoid deep chains of utility types (Pick<Omit<...>>)');
}

function writeReport(tracePath: string, opts: { outJson?: string; top?: number } = {}) {
  const traceFile = join(tracePath, 'trace.json');
  if (!existsSync(traceFile)) {
    console.error(`Trace file not found at ${traceFile}`);
    return;
  }

  let traceContent = readFileSync(traceFile, 'utf-8').trim();
  if (!traceContent.endsWith(']')) {
    traceContent = traceContent.replace(/,\s*$/, '');
    traceContent += ']';
  }

  let trace: TraceEvent[];
  try {
    trace = JSON.parse(traceContent);
  } catch (error) {
    console.error('Failed to parse trace for JSON report');
    return;
  }

  const topN = opts.top || 20;

  const typeChecks = trace.filter((event) => event.name && event.name.includes('check') && event.dur);
  const slowestChecks = typeChecks.sort((a, b) => (b.dur || 0) - (a.dur || 0)).slice(0, topN);

  const instantiations = new Map<string, number>();
  for (const event of trace) {
    if (event.args?.path && event.args?.count) {
      const existing = instantiations.get(event.args.path) || 0;
      instantiations.set(event.args.path, existing + event.args.count);
    }
  }

  const sortedInst = Array.from(instantiations.entries()).sort((a, b) => b[1] - a[1]).slice(0, topN);

  const totalDuration = trace.reduce((sum, event) => sum + (event.dur || 0), 0);

  const report = {
    tracePath,
    topChecks: slowestChecks.map((c) => ({ name: c.name, durationMs: (c.dur || 0) / 1000 })),
    topInstantiations: sortedInst.map(([path, count]) => ({ path, count })),
    totalMs: totalDuration / 1000,
    eventCount: trace.length,
    generatedAt: new Date().toISOString(),
  };

  if (opts.outJson) {
    try {
      writeFileSync(opts.outJson, JSON.stringify(report, null, 2), 'utf-8');
      console.log(`\nüìÅ JSON report written to ${opts.outJson}`);
    } catch (e) {
      console.error('Failed to write JSON report:', e);
    }
  }

  return report;
}

function main() {
  const args = process.argv.slice(2);

  let outJson: string | undefined;
  const jsonIdx = args.indexOf('--json');
  if (jsonIdx !== -1 && args[jsonIdx + 1]) outJson = args[jsonIdx + 1];

  if (args[0] === '--analyze' && args[1]) {
    // Analyze existing trace
    analyzeTrace(args[1]);
    if (outJson) writeReport(args[1], { outJson });
  } else {
    // Generate and analyze
    const tracePath = generateTrace();
    analyzeTrace(tracePath);
    if (outJson) writeReport(tracePath, { outJson });
  }
}

main();
